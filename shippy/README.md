#Create microservices with gRPC/protobuf:

##Microservices Communication - 
	Because microservices are split out into separate codebases, one important issue with microservices, is communication. In a monolith communication is not an issue, as you call code directly from elsewhere in your codebase. However, microservices don't have that ability, as they live in separate places. So you need a way in which these independent services can talk to one another with as little latency as possible.

##What is gRPC?
	gRPC is a light-weight binary based RPC communication protocol brought out by Google.gRPC uses binary as its core data format. In our RESTful example, using JSON, you would be sending a string over http. Strings contain bulky metadata about its encoding format; about its length, its content format and various other bits and pieces. This is so that a server can inform a traditionally browser based client what to expect. We don't really need all of this when communicating between two services. So we can use cold hard binary, which is much more light-weight. gRPC uses the new HTTP 2.0 spec, which allows for the use of binary data. It even allows for bi-directional streaming.
But how can we do anything with binary data? Well, gRPC has an interchange DSL called protobuf. Protobuf allows you to define an interface to your service using a developer friendly format.

##Prerequisites:
-Install the protoc compiler
-Install gRPC/protobuf
-Install go get -u google.golang.org/grpc
-Install go get github.com/golang/protobuf/protoc-gen-go@v1.3



-First of all, create .proto file (e.g. consignment.proto) define your service, this should contain the methods that you wish to expose to other services. Then you define your message types, these are effectively your data structure. Protobuf is statically typed, and you can define custom types.
e.g. In our .proto file,

service ShippingService {
  rpc CreateConsignment(Consignment) returns (Response) {}
}

message Consignment {
  string id = 1;
  string description = 2;
  int32 weight = 3;
  repeated Container containers = 4;
  string vessel_id = 5;
}

-There are two libraries at work, messages are handled by protobuf, and the service we defined is handled by a gRPC protobuf plugin, which compiles code to interact with these types, i.e the service part of our proto file.
-This protobuf definition is then ran through a CLI to generate the code to interface this binary data and your functionality.

```bash
protoc -I. --go_out=plugins=grpc:. \
	  proto/consignment/consignment.proto
```

This the command to run our .proto file. through respective folder.

-This will call the protoc library, which is responsible for compiling your protobuf definition into code. We also specify the use of the grpc plugin, as well as the build context and the output path.
-Now when you run this command in your proto directory, you should see some newly generated code. This is code automatically generated by the gRPC/protobuf libraries to allow you to interface your protobuf definition to your own code.

-Create main.go file which is nothing but our server.and implement service which we have defined in our .proto file. as well create grpc server on whatever port you want.

Then create client for our service. Create shippy-cli-consignment folder from root dir of project.and call our service from their.

